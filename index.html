<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sharp Sync Canvas</title>
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- CSS STYLING --- */
        :root { --bg: #f0f2f5; --sidebar: #2c3e50; --accent: #007bff; --sidebar-width: 50px; }
        
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg); display: flex; height: 100vh; height: 100dvh; }
        
        /* --- LOGIN PANEL --- */
        #loginOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(240, 242, 245, 0.98); z-index: 999;
            display: flex; justify-content: center; align-items: center;
        }
        .login-card {
            background: white; padding: 30px; border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); text-align: center; width: 85%; max-width: 350px;
        }
        .login-card h2 { margin-top: 0; color: #333; font-size: 22px; }
        .login-card input {
            width: 100%; padding: 12px; margin: 15px 0; border: 2px solid #e1e4e8; 
            border-radius: 8px; font-size: 16px; box-sizing: border-box; text-align: center;
        }
        .login-card input:focus { border-color: var(--accent); outline: none; }
        
        .btn {
            width: 100%; padding: 12px; margin: 6px 0; border: none; border-radius: 8px; 
            font-size: 15px; font-weight: 600; cursor: pointer; color: white; transition: 0.2s;
        }
        .btn-host { background: var(--accent); }
        .btn-viewer { background: #28a745; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }

        #status { margin-top: 15px; font-weight: bold; color: #666; font-size: 13px; }

        /* --- MAIN APP --- */
        #appContainer { display: none; width: 100%; height: 100%; }
        
        /* Sidebar */
        #sidebar {
            width: var(--sidebar-width); background: var(--sidebar); 
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 15px; box-shadow: 4px 0 10px rgba(0,0,0,0.1); z-index: 10;
            justify-content: space-between; 
            padding-bottom: 20px; 
        }

        .tools-group {
            display: flex; flex-direction: column; align-items: center; width: 100%;
        }
        
        .tool-btn {
            width: 36px; height: 36px; border: none; background: transparent; color: #aab7c4;
            font-size: 16px; margin: 6px 0; cursor: pointer; border-radius: 8px; transition: 0.2s;
            display: flex; justify-content: center; align-items: center;
        }
        .tool-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .tool-btn.active { background: var(--accent); color: white; }
        
        .divider { width: 50%; height: 1px; background: #44566c; margin: 8px 0; }
        
        .color-opt {
            width: 22px; height: 22px; border-radius: 50%; margin: 6px 0; cursor: pointer;
            border: 2px solid transparent; transition: 0.2s;
        }
        .color-opt.active { border-color: white; transform: scale(1.1); }

        .bottom-group {
            margin-bottom: env(safe-area-inset-bottom, 20px); 
            display: flex; flex-direction: column; align-items: center;
            padding-bottom: 40px; 
        }

        /* Canvas Area */
        #mainArea { flex: 1; position: relative; background: #ddd; display: flex; justify-content: center; align-items: center; }
        
        #canvasWrapper {
            position: relative; background: white; box-shadow: 0 0 20px rgba(0,0,0,0.1);
            width: 100%; height: 100%; overflow: hidden;
        }
        /* Ensure canvas doesn't introduce own scrollbars */
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    </style>
</head>
<body>

    <!-- LOGIN -->
    <div id="loginOverlay">
        <div class="login-card">
            <h2><i class="fas fa-pencil-alt"></i> Sharp Sync</h2>
            <input type="text" id="roomId" placeholder="Enter Room ID">
            <button class="btn btn-host" id="btnHost" onclick="startHost()">Start as HOST</button>
            <button class="btn btn-viewer" id="btnViewer" onclick="startViewer()">Join as VIEWER</button>
            <div id="status">Ready.</div>
        </div>
    </div>

    <!-- APP -->
    <div id="appContainer">
        <div id="sidebar">
            <div class="tools-group">
                <button class="tool-btn active" id="t-pen" onclick="setTool('pen')"><i class="fas fa-pen"></i></button>
                <button class="tool-btn" id="t-eraser" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
                
                <div class="divider"></div>
                
                <div class="color-opt active" style="background: #000;" onclick="setColor('#000000', this)"></div>
                <div class="color-opt" style="background: #dc3545;" onclick="setColor('#dc3545', this)"></div>
                <div class="color-opt" style="background: #28a745;" onclick="setColor('#28a745', this)"></div>
                <div class="color-opt" style="background: #007bff;" onclick="setColor('#007bff', this)"></div>
            </div>

            <div class="bottom-group">
                <button class="tool-btn" onclick="clearCanvas()"><i class="fas fa-trash"></i></button>
                <button class="tool-btn" onclick="toggleFullScreen()"><i class="fas fa-expand"></i></button>
            </div>
        </div>

        <div id="mainArea">
            <div id="canvasWrapper">
                <canvas id="drawCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbznWr6pH1DLfDXVAKneaQiWKkf-yQFBwm26o9ecU-Z8grk2X7L_lzWrzxP-c02aWMZ1/exec';
        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        
        const pc = new RTCPeerConnection(config);
        let dataChannel = null;
        let intervalId = null;

        // State
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentLineWidth = 4; // Slightly thicker for visibility
        
        // Drawing State
        let isDrawing = false;
        let points = []; // Array to store points for smoothing

        // DOM
        const statusEl = document.getElementById('status');
        const loginOverlay = document.getElementById('loginOverlay');
        const appContainer = document.getElementById('appContainer');
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const roomIdInput = document.getElementById('roomId');

        // --- HIGH DPI CANVAS SETUP (Fixes Pixelation) ---
        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const rect = wrapper.getBoundingClientRect();
            
            // Save current image data to restore after resize
            let savedData = null;
            if (canvas.width > 0) {
                savedData = canvas.toDataURL();
            }

            // Get Device Pixel Ratio (DPR) - typically 2 or 3 on phones
            const dpr = window.devicePixelRatio || 1;

            // Set actual size in memory (scaled to account for extra pixel density)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Normalize coordinate system to use css pixels
            ctx.scale(dpr, dpr);

            // Set white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, rect.width, rect.height);

            // Restore image
            if (savedData) {
                const img = new Image();
                img.onload = () => ctx.drawImage(img, 0, 0, rect.width, rect.height);
                img.src = savedData;
            }
        }
        window.addEventListener('resize', resizeCanvas);

        // --- NETWORK ---
        async function sendToSheet(type, sdp) {
            statusEl.textContent = "Syncing...";
            try {
                await fetch(SCRIPT_URL, {
                    method: 'POST', mode: 'no-cors', 
                    headers: { 'Content-Type': 'text/plain' }, 
                    body: JSON.stringify({ id: roomIdInput.value.trim(), type: type, sdp: JSON.stringify(sdp) })
                });
            } catch(e) { statusEl.textContent = "Network Error"; }
        }

        async function readFromSheet() {
            const response = await fetch(`${SCRIPT_URL}?id=${roomIdInput.value.trim()}`);
            return await response.json();
        }

        pc.onconnectionstatechange = () => {
            if (pc.connectionState === "connected") {
                clearInterval(intervalId);
                statusEl.textContent = "Connected!";
                loginOverlay.style.display = 'none';
                appContainer.style.display = 'flex';
                resizeCanvas();
            }
        };

        // Host
        async function startHost() {
            if(!roomIdInput.value) return alert("Enter ID");
            document.getElementById('btnHost').disabled = true;
            dataChannel = pc.createDataChannel("draw");
            setupDrawingEvents();
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            pc.onicecandidate = async (e) => {
                if (!e.candidate) {
                    await sendToSheet('offer', pc.localDescription);
                    statusEl.textContent = "Waiting for Viewer...";
                    intervalId = setInterval(async () => {
                        const data = await readFromSheet();
                        if (data.answer) {
                            clearInterval(intervalId);
                            statusEl.textContent = "Connecting...";
                            await pc.setRemoteDescription(JSON.parse(data.answer));
                        }
                    }, 2000);
                }
            };
        }

        // Viewer
        async function startViewer() {
            if(!roomIdInput.value) return alert("Enter ID");
            document.getElementById('btnViewer').disabled = true;
            statusEl.textContent = "Searching...";
            intervalId = setInterval(async () => {
                const data = await readFromSheet();
                if (data.offer && pc.signalingState === "stable") {
                    clearInterval(intervalId);
                    statusEl.textContent = "Joining...";
                    await pc.setRemoteDescription(JSON.parse(data.offer));
                    pc.ondatachannel = (e) => { e.channel.onmessage = handleIncomingDraw; };
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    pc.onicecandidate = async (e) => {
                        if (!e.candidate) await sendToSheet('answer', pc.localDescription);
                    };
                }
            }, 2000);
        }

        // --- SHARP & SMOOTH DRAWING LOGIC ---

        function getPos(e) {
            // e.clientX/Y are already in CSS pixels, which is what we want 
            // because we used ctx.scale() to handle the high DPI
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function setupDrawingEvents() {
            const start = (e) => {
                e.preventDefault();
                isDrawing = true;
                const p = getPos(e);
                points = [p]; // Start new array of points
                
                // Send Start config
                sendData({
                    t: 's', x: p.x, y: p.y,
                    c: (currentTool === 'eraser' ? '#ffffff' : currentColor),
                    w: (currentTool === 'eraser' ? 30 : currentLineWidth)
                });

                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                // Just draw a dot initially
                ctx.lineTo(p.x, p.y); 
                ctx.stroke();
                
                // Set context for this stroke
                ctx.strokeStyle = (currentTool === 'eraser' ? '#ffffff' : currentColor);
                ctx.lineWidth = (currentTool === 'eraser' ? 30 : currentLineWidth);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            };

            const move = (e) => {
                e.preventDefault();
                if (!isDrawing) return;

                const p = getPos(e);
                points.push(p);

                // --- MIDPOINT ALGORITHM ---
                // This draws quadratic curves between the midpoints of input coordinates.
                // It is the industry standard for smooth lines without lag.
                if (points.length > 2) {
                    const last = points[points.length - 2];
                    const prev = points[points.length - 3];
                    
                    // Calculate midpoints
                    const midX = (last.x + p.x) / 2;
                    const midY = (last.y + p.y) / 2;

                    // Draw curve from last anchor to new midpoint
                    // Using the 'last' point as the Control Point
                    ctx.quadraticCurveTo(last.x, last.y, midX, midY);
                    ctx.stroke();
                    
                    // We only send the raw point, the remote side will calculate the same curve
                    sendData({t: 'd', x: p.x, y: p.y});
                }
            };

            const end = () => { 
                isDrawing = false; 
                points = [];
            };

            canvas.addEventListener('mousedown', start);
            canvas.addEventListener('mousemove', move);
            canvas.addEventListener('mouseup', end);
            canvas.addEventListener('touchstart', start, {passive: false});
            canvas.addEventListener('touchmove', move, {passive: false});
            canvas.addEventListener('touchend', end);
        }

        function sendData(obj) {
            if (dataChannel && dataChannel.readyState === 'open') {
                // Normalize to 0-1 for network sending
                const rect = canvas.getBoundingClientRect(); // Get CSS Size
                const payload = { ...obj };
                
                if(payload.x) payload.x = payload.x / rect.width;
                if(payload.y) payload.y = payload.y / rect.height;
                
                dataChannel.send(JSON.stringify(payload));
            }
        }

        // --- REMOTE HANDLER ---
        // Remote side must mimic the smoothing logic
        let rPoints = [];

        function handleIncomingDraw(e) {
            const d = JSON.parse(e.data);
            // Get CSS dimensions
            const rect = canvas.getBoundingClientRect();
            const w = rect.width;
            const h = rect.height;

            if(d.t === 's') {
                rPoints = [{x: d.x * w, y: d.y * h}];
                ctx.beginPath();
                ctx.moveTo(rPoints[0].x, rPoints[0].y);
                ctx.strokeStyle = d.c;
                ctx.lineWidth = d.w;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            } 
            else if(d.t === 'd') {
                const p = {x: d.x * w, y: d.y * h};
                rPoints.push(p);

                if (rPoints.length > 2) {
                    const last = rPoints[rPoints.length - 2];
                    const midX = (last.x + p.x) / 2;
                    const midY = (last.y + p.y) / 2;
                    ctx.quadraticCurveTo(last.x, last.y, midX, midY);
                    ctx.stroke();
                }
            }
            else if(d.t === 'cls') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, rect.width, rect.height);
            }
        }

        // --- UI ---
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('t-'+tool).classList.add('active');
        }

        function setColor(color, el) {
            setTool('pen');
            currentColor = color;
            document.querySelectorAll('.color-opt').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
        }

        function clearCanvas() {
            if(confirm("Clear?")) {
                const rect = canvas.getBoundingClientRect();
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, rect.width, rect.height);
                sendData({t: 'cls'});
            }
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

    </script>
</body>
</html>