<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vector Sync Canvas</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- CSS STYLING --- */
        :root { --bg: #f0f2f5; --sidebar: #2c3e50; --accent: #007bff; --sidebar-width: 60px; }
        
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg); display: flex; height: 100vh; height: 100dvh; touch-action: none; }
        
        /* --- LOGIN PANEL --- */
        #loginOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(240, 242, 245, 0.98); z-index: 999;
            display: flex; justify-content: center; align-items: center;
        }
        .login-card {
            background: white; padding: 30px; border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); text-align: center; width: 85%; max-width: 350px;
        }
        .login-card input {
            width: 100%; padding: 12px; margin: 15px 0; border: 2px solid #e1e4e8; 
            border-radius: 8px; font-size: 16px; box-sizing: border-box; text-align: center;
        }
        .btn {
            width: 100%; padding: 12px; margin: 6px 0; border: none; border-radius: 8px; 
            font-size: 15px; font-weight: 600; cursor: pointer; color: white; transition: 0.2s;
        }
        .btn-host { background: var(--accent); }
        .btn-viewer { background: #28a745; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        #status { margin-top: 15px; font-weight: bold; color: #666; font-size: 13px; }

        /* --- MAIN APP --- */
        #appContainer { display: none; width: 100%; height: 100%; }
        
        /* Sidebar */
        #sidebar {
            width: var(--sidebar-width); background: var(--sidebar); 
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 15px; box-shadow: 4px 0 10px rgba(0,0,0,0.1); z-index: 10;
            justify-content: space-between; padding-bottom: 20px; 
        }

        .tool-btn {
            width: 40px; height: 40px; border: none; background: transparent; color: #aab7c4;
            font-size: 18px; margin: 6px 0; cursor: pointer; border-radius: 8px; transition: 0.2s;
            display: flex; justify-content: center; align-items: center;
        }
        .tool-btn.active { background: var(--accent); color: white; }
        
        .color-opt {
            width: 24px; height: 24px; border-radius: 50%; margin: 8px 0; cursor: pointer;
            border: 2px solid transparent; transition: 0.2s;
        }
        .color-opt.active { border-color: white; transform: scale(1.1); }

        /* Slider for Stroke Size */
        .size-slider-container {
            display: flex; flex-direction: column; align-items: center; margin: 10px 0;
            color: #aab7c4; font-size: 10px;
        }
        input[type=range] {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* Webkit */
            width: 8px; height: 60px; padding: 0 5px;
            margin-top: 5px;
        }

        /* Canvas Area */
        #mainArea { flex: 1; position: relative; background: #ddd; display: flex; justify-content: center; align-items: center; }
        #canvasWrapper {
            position: relative; background: white; box-shadow: 0 0 20px rgba(0,0,0,0.1);
            width: 100%; height: 100%; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        /* Page Controls */
        #pageControls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--sidebar); padding: 8px 15px; border-radius: 30px; color: white;
            display: flex; align-items: center; gap: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-size: 14px; font-weight: bold; pointer-events: auto;
        }
        .pg-btn { background: none; border: none; color: white; cursor: pointer; font-size: 16px; }
        .pg-btn:disabled { opacity: 0.5; cursor: default; }

    </style>
</head>
<body>

    <!-- LOGIN -->
    <div id="loginOverlay">
        <div class="login-card">
            <h2><i class="fas fa-layer-group"></i> Vector Sync</h2>
            <input type="text" id="roomId" placeholder="Enter Room ID">
            <button class="btn btn-host" id="btnHost" onclick="startHost()">Start as HOST</button>
            <button class="btn btn-viewer" id="btnViewer" onclick="startViewer()">Join as VIEWER</button>
            <div id="status">Ready.</div>
        </div>
    </div>

    <!-- APP -->
    <div id="appContainer">
        <div id="sidebar">
            <div style="display:flex; flex-direction:column; align-items:center;">
                <button class="tool-btn active" id="t-pen" onclick="setTool('pen')"><i class="fas fa-pen"></i></button>
                <button class="tool-btn" id="t-eraser" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
                
                <div style="width:50%; height:1px; background:#44566c; margin:10px 0;"></div>
                
                <!-- Size Slider -->
                <div class="size-slider-container">
                    <i class="fas fa-circle" style="font-size: 8px;"></i>
                    <input type="range" min="1" max="20" value="3" id="sizeSlider" oninput="updateSize(this.value)">
                    <i class="fas fa-circle" style="font-size: 14px; margin-top:5px;"></i>
                </div>

                <div style="width:50%; height:1px; background:#44566c; margin:10px 0;"></div>
                
                <div class="color-opt active" style="background: #000;" onclick="setColor('#000000', this)"></div>
                <div class="color-opt" style="background: #dc3545;" onclick="setColor('#dc3545', this)"></div>
                <div class="color-opt" style="background: #28a745;" onclick="setColor('#28a745', this)"></div>
                <div class="color-opt" style="background: #007bff;" onclick="setColor('#007bff', this)"></div>
            </div>

            <div style="margin-bottom: 20px; display: flex; flex-direction: column;">
                <button class="tool-btn" onclick="toggleFullScreen()"><i class="fas fa-expand"></i></button>
            </div>
        </div>

        <div id="mainArea">
            <div id="canvasWrapper">
                <canvas id="drawCanvas"></canvas>
            </div>
            
            <!-- Page UI -->
            <div id="pageControls">
                <button class="pg-btn" onclick="changePage(-1)"><i class="fas fa-chevron-left"></i></button>
                <span id="pageDisplay">Page 1</span>
                <button class="pg-btn" onclick="changePage(1)"><i class="fas fa-chevron-right"></i></button>
                <button class="pg-btn" style="margin-left:10px" onclick="deletePage()" title="Clear Page"><i class="fas fa-trash-alt"></i></button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbznWr6pH1DLfDXVAKneaQiWKkf-yQFBwm26o9ecU-Z8grk2X7L_lzWrzxP-c02aWMZ1/exec';
        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        
        const pc = new RTCPeerConnection(config);
        let dataChannel = null;
        let intervalId = null;

        // --- APP STATE ---
        let isHost = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentSize = 3;

        // --- DATA STRUCTURE (The Magic Part) ---
        // pages = [  [stroke1, stroke2], [stroke1]  ]
        let pages = [ [] ]; 
        let currentPageIndex = 0;

        // DOM
        const statusEl = document.getElementById('status');
        const loginOverlay = document.getElementById('loginOverlay');
        const appContainer = document.getElementById('appContainer');
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // false = faster
        const roomIdInput = document.getElementById('roomId');
        const pageDisplay = document.getElementById('pageDisplay');

        // --- HIGH DPI CANVAS ---
        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const rect = wrapper.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Important: Reset context scale
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);

            redrawCanvas(); // Redraw all strokes for current page
        }
        window.addEventListener('resize', resizeCanvas);

        // --- THE REDRAW ENGINE ---
        function redrawCanvas() {
            const rect = canvas.getBoundingClientRect(); // CSS size
            
            // 1. Clear Screen
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, rect.width, rect.height);

            // 2. Get strokes for current page
            const strokes = pages[currentPageIndex] || [];

            // 3. Draw every stroke
            strokes.forEach(stroke => {
                if (stroke.isErased) return; // Skip deleted strokes

                ctx.beginPath();
                
                // Convert normalized (0-1) coords back to screen pixels
                const p0 = stroke.points[0];
                const startX = p0.x * rect.width;
                const startY = p0.y * rect.height;

                ctx.moveTo(startX, startY);
                
                // Only draw if multiple points
                if (stroke.points.length > 1) {
                    for (let i = 1; i < stroke.points.length; i++) {
                        // Midpoint Smoothing Logic applied to historic data
                        const curr = stroke.points[i];
                        const prev = stroke.points[i-1];
                        
                        // Re-calculate pixel positions
                        const currX = curr.x * rect.width;
                        const currY = curr.y * rect.height;
                        const prevX = prev.x * rect.width;
                        const prevY = prev.y * rect.height;

                        if(i === 1) {
                            ctx.lineTo(currX, currY); // First point connect
                        } else {
                            const midX = (prevX + currX) / 2;
                            const midY = (prevY + currY) / 2;
                            const ppX = stroke.points[i-2].x * rect.width; // previous-previous
                            const ppY = stroke.points[i-2].y * rect.height;
                            
                            // Standard quadratic curve logic
                            ctx.quadraticCurveTo(prevX, prevY, midX, midY);
                        }
                    }
                    // Connect final point
                    const last = stroke.points[stroke.points.length-1];
                    ctx.lineTo(last.x * rect.width, last.y * rect.height);
                } else {
                    // Single dot
                    ctx.lineTo(startX, startY);
                }

                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            });
        }

        // --- INTERACTION LOGIC ---
        let isDrawing = false;
        let activeStroke = null; // The stroke currently being drawn

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top,
                // Store normalized immediately for data consistency
                nx: (clientX - rect.left) / rect.width,
                ny: (clientY - rect.top) / rect.height
            };
        }

        function start(e) {
            e.preventDefault();
            const p = getPos(e);

            if (currentTool === 'eraser') {
                handleEraserClick(p);
                return;
            }

            isDrawing = true;
            
            // Create new stroke object
            activeStroke = {
                id: Date.now() + Math.random().toString(), // Unique ID
                points: [{x: p.nx, y: p.ny}],
                color: currentColor,
                size: currentSize,
                isErased: false
            };
            
            // Add to current page
            if(!pages[currentPageIndex]) pages[currentPageIndex] = [];
            pages[currentPageIndex].push(activeStroke);

            // Network: Send Start
            sendData({ t: 's', id: activeStroke.id, x: p.nx, y: p.ny, c: currentColor, w: currentSize });

            redrawCanvas(); // Render new state
        }

        function move(e) {
            e.preventDefault();
            if (!isDrawing || !activeStroke) return;

            const p = getPos(e);
            
            // Add point to data
            activeStroke.points.push({x: p.nx, y: p.ny});

            // Network: Send Point
            sendData({ t: 'd', id: activeStroke.id, x: p.nx, y: p.ny });

            redrawCanvas(); // Re-render scene
        }

        function end() {
            isDrawing = false;
            activeStroke = null;
        }

        // --- OBJECT ERASER LOGIC ---
        function handleEraserClick(pos) {
            const strokes = pages[currentPageIndex] || [];
            const rect = canvas.getBoundingClientRect();
            const threshold = 15; // Pixel distance tolerance

            // Loop backwards (erase top items first)
            for (let i = strokes.length - 1; i >= 0; i--) {
                const s = strokes[i];
                if (s.isErased) continue;

                // Check every point in the stroke
                for (let pt of s.points) {
                    const px = pt.x * rect.width;
                    const py = pt.y * rect.height;
                    
                    const dist = Math.hypot(px - pos.x, py - pos.y);
                    
                    if (dist < threshold) {
                        // HIT! Erase whole stroke
                        s.isErased = true;
                        sendData({ t: 'del', id: s.id }); // Tell peer to delete
                        redrawCanvas();
                        return; // Only erase one at a time
                    }
                }
            }
        }

        // --- NETWORK HANDLER ---
        // We must build the same data structure on the Viewer side
        function handleIncomingMsg(e) {
            const d = JSON.parse(e.data);
            
            // Ensure page array exists
            if(!pages[currentPageIndex]) pages[currentPageIndex] = [];

            if (d.t === 's') {
                // Remote started new stroke
                const newStroke = {
                    id: d.id,
                    points: [{x: d.x, y: d.y}],
                    color: d.c,
                    size: d.w,
                    isErased: false
                };
                pages[currentPageIndex].push(newStroke);
            } 
            else if (d.t === 'd') {
                // Find the stroke and append point
                const s = pages[currentPageIndex].find(st => st.id === d.id);
                if (s) s.points.push({x: d.x, y: d.y});
            } 
            else if (d.t === 'del') {
                // Mark stroke as erased
                const s = pages[currentPageIndex].find(st => st.id === d.id);
                if (s) s.isErased = true;
            }
            else if (d.t === 'pg') {
                // Change Page
                currentPageIndex = d.i;
                if (!pages[currentPageIndex]) pages[currentPageIndex] = [];
                updatePageUI();
            }
            else if (d.t === 'clr') {
                // Clear current page
                pages[currentPageIndex] = [];
            }

            redrawCanvas();
        }

        // --- WEBRTC CONNECTION (Same as before) ---
        async function sendToSheet(type, sdp) {
            statusEl.textContent = "Syncing...";
            try {
                await fetch(SCRIPT_URL, {
                    method: 'POST', mode: 'no-cors', 
                    headers: { 'Content-Type': 'text/plain' }, 
                    body: JSON.stringify({ id: roomIdInput.value.trim(), type: type, sdp: JSON.stringify(sdp) })
                });
            } catch(e) {}
        }

        async function readFromSheet() {
            const response = await fetch(`${SCRIPT_URL}?id=${roomIdInput.value.trim()}`);
            return await response.json();
        }

        pc.onconnectionstatechange = () => {
            if (pc.connectionState === "connected") {
                clearInterval(intervalId);
                statusEl.textContent = "Connected!";
                loginOverlay.style.display = 'none';
                appContainer.style.display = 'flex';
                resizeCanvas();
            }
        };

        async function startHost() {
            if(!roomIdInput.value) return alert("Enter ID");
            isHost = true;
            document.getElementById('btnHost').disabled = true;
            dataChannel = pc.createDataChannel("draw");
            setupEvents();
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            pc.onicecandidate = async (e) => {
                if (!e.candidate) {
                    await sendToSheet('offer', pc.localDescription);
                    statusEl.textContent = "Waiting for Viewer...";
                    intervalId = setInterval(async () => {
                        const data = await readFromSheet();
                        if (data.answer) {
                            clearInterval(intervalId);
                            statusEl.textContent = "Connecting...";
                            await pc.setRemoteDescription(JSON.parse(data.answer));
                        }
                    }, 2000);
                }
            };
        }

        async function startViewer() {
            if(!roomIdInput.value) return alert("Enter ID");
            isHost = false;
            document.getElementById('btnViewer').disabled = true;
            statusEl.textContent = "Searching...";
            intervalId = setInterval(async () => {
                const data = await readFromSheet();
                if (data.offer && pc.signalingState === "stable") {
                    clearInterval(intervalId);
                    statusEl.textContent = "Joining...";
                    await pc.setRemoteDescription(JSON.parse(data.offer));
                    pc.ondatachannel = (e) => { e.channel.onmessage = handleIncomingMsg; };
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    pc.onicecandidate = async (e) => {
                        if (!e.candidate) await sendToSheet('answer', pc.localDescription);
                    };
                }
            }, 2000);
        }

        function setupEvents() {
            canvas.addEventListener('mousedown', start);
            canvas.addEventListener('mousemove', move);
            canvas.addEventListener('mouseup', end);
            canvas.addEventListener('touchstart', start, {passive: false});
            canvas.addEventListener('touchmove', move, {passive: false});
            canvas.addEventListener('touchend', end);
        }

        function sendData(obj) {
            if (dataChannel && dataChannel.readyState === 'open') dataChannel.send(JSON.stringify(obj));
        }

        // --- UI HELPERS ---
        function setTool(t) { currentTool = t; updateBtnState(); }
        function setColor(c, el) { 
            currentTool = 'pen'; currentColor = c; 
            document.querySelectorAll('.color-opt').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
            updateBtnState();
        }
        function updateSize(val) { currentSize = parseInt(val); }
        function updateBtnState() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('t-'+currentTool).classList.add('active');
        }

        // --- PAGES LOGIC ---
        function changePage(dir) {
            // Only host can change pages to keep sync simple
            if (!isHost) return alert("Only Host can change pages");
            
            const next = currentPageIndex + dir;
            if (next < 0) return;

            currentPageIndex = next;
            // Init array if new page
            if (!pages[currentPageIndex]) pages[currentPageIndex] = [];
            
            updatePageUI();
            sendData({ t: 'pg', i: currentPageIndex });
            redrawCanvas();
        }

        function deletePage() {
            if (!isHost) return;
            if (confirm("Clear this page?")) {
                pages[currentPageIndex] = [];
                sendData({ t: 'clr' });
                redrawCanvas();
            }
        }

        function updatePageUI() {
            pageDisplay.innerText = "Page " + (currentPageIndex + 1);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }
    </script>
</body>
</html>