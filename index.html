<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smooth P2P Canvas</title>
    
    <!-- Icons & PDF Lib -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        :root { --primary: #2c3e50; --accent: #e67e22; --bg: #ecf0f1; }
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #333; display: flex; height: 100vh; width: 100vw; }

        /* --- LOGIN --- */
        #loginOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 999;
            display: flex; justify-content: center; align-items: center;
        }
        .login-box { background: white; padding: 30px; border-radius: 12px; text-align: center; width: 300px; }
        .login-box input { width: 100%; padding: 10px; margin: 10px 0; box-sizing: border-box; }
        .btn { width: 100%; padding: 10px; margin: 5px 0; cursor: pointer; border: none; color: white; font-weight: bold; border-radius: 5px; }
        .btn-host { background: #2980b9; } .btn-join { background: #27ae60; }

        /* --- UI --- */
        #sidebar {
            width: 60px; background: var(--primary); display: flex; flex-direction: column; align-items: center; padding-top: 10px; z-index: 100;
            box-shadow: 2px 0 5px rgba(0,0,0,0.3);
        }
        .tool-btn {
            width: 40px; height: 40px; border-radius: 8px; border: none; background: transparent; color: #ecf0f1;
            font-size: 18px; margin: 8px 0; cursor: pointer; transition: 0.2s;
        }
        .tool-btn.active { background: var(--accent); color: white; transform: scale(1.1); }
        
        .color-dot { width: 24px; height: 24px; border-radius: 50%; border: 2px solid #fff; margin: 6px 0; cursor: pointer; }
        
        #main { flex: 1; position: relative; background: #666; display: flex; justify-content: center; align-items: center; }
        
        #canvasWrapper {
            position: relative; width: 100%; height: 100%; background: white; overflow: hidden;
        }
        
        canvas { display: block; cursor: crosshair; touch-action: none; }

        #pageControls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: #2c3e50; padding: 8px 20px; border-radius: 30px; color: white; 
            display: flex; align-items: center; gap: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .icon-btn { background: none; border: none; color: white; cursor: pointer; font-size: 16px; }

        /* Status toast */
        #toast {
            position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); 
            color: white; padding: 5px 15px; border-radius: 20px; font-size: 12px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loginOverlay">
        <div class="login-box">
            <h2><i class="fas fa-palette"></i> ArtSync</h2>
            <input type="text" id="roomId" placeholder="Enter Room Name">
            <button class="btn btn-host" onclick="initApp('host')">Create Room (Host)</button>
            <button class="btn btn-join" onclick="initApp('join')">Join Room (Viewer)</button>
            <p id="statusText" style="font-size:12px; color:#777;">Waiting...</p>
        </div>
    </div>

    <div id="sidebar">
        <button class="tool-btn active" id="t-pen" onclick="setTool('pen')"><i class="fas fa-pen"></i></button>
        <button class="tool-btn" id="t-eraser" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
        
        <div style="height:1px; bg:#555; width:80%; margin:10px 0;"></div>
        
        <div class="color-dot" style="background:#000;" onclick="setColor('#000000')"></div>
        <div class="color-dot" style="background:#e74c3c;" onclick="setColor('#e74c3c')"></div>
        <div class="color-dot" style="background:#3498db;" onclick="setColor('#3498db')"></div>
        <div class="color-dot" style="background:#2ecc71;" onclick="setColor('#2ecc71')"></div>
        
        <div style="height:1px; bg:#555; width:80%; margin:auto;"></div>
        
        <button class="tool-btn" onclick="downloadPDF()"><i class="fas fa-file-pdf"></i></button>
        <button class="tool-btn" onclick="toggleFS()"><i class="fas fa-expand"></i></button>
    </div>

    <div id="main">
        <div id="toast">Offline</div>
        <div id="canvasWrapper">
            <canvas id="cvs"></canvas>
        </div>
        <div id="pageControls">
            <button class="icon-btn" onclick="changePage(-1)"><i class="fas fa-chevron-left"></i></button>
            <span id="pgNum">Page 1</span>
            <button class="icon-btn" onclick="changePage(1)"><i class="fas fa-chevron-right"></i></button>
            <button class="icon-btn" onclick="clearCanvas()"><i class="fas fa-trash"></i></button>
        </div>
    </div>

    <script>
        // ==========================================
        // !!! PASTE YOUR GOOGLE SCRIPT URL HERE !!!
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbznWr6pH1DLfDXVAKneaQiWKkf-yQFBwm26o9ecU-Z8grk2X7L_lzWrzxP-c02aWMZ1/exec'; 
        // ==========================================

        const cvs = document.getElementById('cvs');
        const ctx = cvs.getContext('2d', { alpha: false }); // Optimization
        
        // --- APP STATE ---
        const state = {
            isHost: false,
            roomId: '',
            tool: 'pen',
            color: '#000000',
            lineWidth: 3,
            drawing: false,
            pages: [],
            curPage: 0
        };

        // Remote State (What the viewer thinks the host is doing)
        const remoteState = {
            x: 0, y: 0,
            color: '#000000',
            tool: 'pen',
            lineWidth: 3
        };

        // --- WEBRTC ---
        const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
        let dc; // DataChannel

        function resize() {
            // Save content
            const temp = cvs.toDataURL();
            cvs.width = cvs.parentElement.clientWidth;
            cvs.height = cvs.parentElement.clientHeight;
            
            // White background (important for eraser)
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, cvs.width, cvs.height);
            
            // Restore content
            const img = new Image();
            img.onload = () => ctx.drawImage(img, 0, 0);
            img.src = temp;
        }
        window.onresize = resize;

        async function initApp(role) {
            state.roomId = document.getElementById('roomId').value.trim();
            if(!state.roomId || SCRIPT_URL.includes("YOUR_GOOGLE")) return alert("Config Error");
            
            state.isHost = (role === 'host');
            document.getElementById('loginOverlay').style.display = 'none';
            resize();
            savePage();

            if(state.isHost) {
                dc = pc.createDataChannel("draw");
                setupDC();
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                pc.onicecandidate = e => !e.candidate && sendSignal('offer', pc.localDescription);
                poll('answer');
            } else {
                document.getElementById('pageControls').style.pointerEvents = 'none'; // Disable viewer controls
                document.getElementById('pageControls').style.opacity = '0.5';
                poll('offer');
            }
        }

        // --- SIGNALING ---
        async function sendSignal(type, data) {
            await fetch(SCRIPT_URL, {
                method: 'POST', mode: 'no-cors',
                headers: {'Content-Type': 'text/plain'},
                body: JSON.stringify({ id: state.roomId, type, sdp: JSON.stringify(data) })
            });
        }

        function poll(targetType) {
            const pid = setInterval(async () => {
                const res = await fetch(`${SCRIPT_URL}?id=${state.roomId}`);
                const json = await res.json();
                
                if(targetType === 'answer' && json.answer) {
                    clearInterval(pid);
                    pc.setRemoteDescription(JSON.parse(json.answer));
                } 
                else if(targetType === 'offer' && json.offer) {
                    clearInterval(pid);
                    pc.setRemoteDescription(JSON.parse(json.offer));
                    pc.ondatachannel = e => { dc = e.channel; setupDC(); };
                    const ans = await pc.createAnswer();
                    await pc.setLocalDescription(ans);
                    pc.onicecandidate = e => !e.candidate && sendSignal('answer', pc.localDescription);
                }
            }, 2000);
        }

        function setupDC() {
            document.getElementById('toast').innerText = "Connected";
            document.getElementById('toast').style.backgroundColor = "#27ae60";
            dc.onmessage = e => handleMsg(JSON.parse(e.data));
        }

        function send(data) {
            if(dc && dc.readyState === 'open') dc.send(JSON.stringify(data));
        }

        // --- DRAWING ENGINE (BEZIER INTERPOLATION) ---
        
        function getPos(e) {
            const r = cvs.getBoundingClientRect();
            const t = e.touches ? e.touches[0] : e;
            return { x: t.clientX - r.left, y: t.clientY - r.top };
        }

        // Local Draw Handlers
        cvs.addEventListener('mousedown', start);
        cvs.addEventListener('touchstart', start, {passive: false});
        
        cvs.addEventListener('mousemove', move);
        cvs.addEventListener('touchmove', move, {passive: false});
        
        window.addEventListener('mouseup', end);
        window.addEventListener('touchend', end);

        let points = [];

        function start(e) {
            if(!state.isHost && !dc) return; // Allow viewer to draw locally? Usually no.
            // Uncomment to lock viewer drawing: if(!state.isHost) return; 
            
            e.preventDefault(); // Prevent scroll
            state.drawing = true;
            const p = getPos(e);
            points = [p]; // Start path
            
            // Configure Context IMMEDIATELY
            configureContext(ctx, state.tool, state.color, state.lineWidth);
            
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            
            // Send Start Signal (Contains Color/Tool info!)
            send({ 
                t: 's', 
                x: p.x / cvs.width, 
                y: p.y / cvs.height,
                c: state.color,
                w: state.lineWidth,
                tl: state.tool 
            });
        }

        function move(e) {
            if(!state.drawing) return;
            e.preventDefault();
            const p = getPos(e);
            points.push(p);
            
            // Smooth Curve Logic
            if(points.length > 2) {
                const last = points[points.length - 2];
                const prev = points[points.length - 3];
                const midX = (last.x + p.x) / 2;
                const midY = (last.y + p.y) / 2;
                
                // We draw from the previous midpoint to the current midpoint
                // Using 'last' as the control point.
                // NOTE: For realtime, we cheat slightly and use quadCurveTo
                // from last point to current point, but using midpoint is smoother.
                
                // Simplest smooth approach for P2P:
                ctx.quadraticCurveTo(last.x, last.y, (last.x + p.x)/2, (last.y + p.y)/2);
                ctx.stroke();
            } else {
                // Just starting, draw line to get immediate feedback
                ctx.lineTo(p.x, p.y);
                ctx.stroke();
            }

            send({ t: 'm', x: p.x / cvs.width, y: p.y / cvs.height });
        }

        function end() {
            if(!state.drawing) return;
            state.drawing = false;
            ctx.closePath();
            points = [];
            savePage();
            send({ t: 'e' }); // End
        }

        // Helper to set context props
        function configureContext(context, tool, color, width) {
            context.lineCap = 'round';
            context.lineJoin = 'round';
            if(tool === 'eraser') {
                context.globalCompositeOperation = 'destination-out';
                context.lineWidth = 20;
            } else {
                context.globalCompositeOperation = 'source-over';
                context.strokeStyle = color;
                context.lineWidth = width;
            }
        }

        // --- REMOTE HANDLER ---
        // This ensures Viewer sees exactly what Host sets
        let rPoints = [];
        
        function handleMsg(d) {
            const w = cvs.width;
            const h = cvs.height;

            if(d.t === 's') {
                // Start: Update Remote State with Tool/Color info
                remoteState.tool = d.tl;
                remoteState.color = d.c;
                remoteState.lineWidth = d.w;
                
                const rx = d.x * w;
                const ry = d.y * h;
                rPoints = [{x: rx, y: ry}];

                // Configure Context for Remote Stroke
                configureContext(ctx, remoteState.tool, remoteState.color, remoteState.lineWidth);
                
                ctx.beginPath();
                ctx.moveTo(rx, ry);
            }
            else if(d.t === 'm') {
                const p = { x: d.x * w, y: d.y * h };
                rPoints.push(p);
                
                // Apply same smoothing logic
                if(rPoints.length > 2) {
                    const last = rPoints[rPoints.length - 2];
                    ctx.quadraticCurveTo(last.x, last.y, (last.x + p.x)/2, (last.y + p.y)/2);
                    ctx.stroke();
                } else {
                    ctx.lineTo(p.x, p.y);
                    ctx.stroke();
                }
            }
            else if(d.t === 'e') {
                ctx.closePath();
                rPoints = [];
                savePage();
            }
            else if(d.t === 'pg') {
                state.curPage = d.i;
                loadPage(d.i);
                document.getElementById('pgNum').innerText = "Page " + (d.i+1);
            }
            else if(d.t === 'cls') {
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0,0,cvs.width, cvs.height);
                savePage();
            }
        }

        // --- TOOLS ---
        function setTool(t) {
            state.tool = t;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(t === 'pen' ? 't-pen' : 't-eraser').classList.add('active');
        }
        function setColor(c) {
            state.color = c;
            setTool('pen');
        }
        function toggleFS() {
            if(!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        }
        function clearCanvas() {
            if(confirm("Clear Page?")) {
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0,0,cvs.width, cvs.height);
                savePage();
                send({t:'cls'});
            }
        }

        // --- PAGES & PDF ---
        function savePage() {
            state.pages[state.curPage] = cvs.toDataURL();
        }
        function loadPage(i) {
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0,0,cvs.width, cvs.height);
            if(state.pages[i]) {
                const img = new Image();
                img.onload = () => ctx.drawImage(img, 0, 0, cvs.width, cvs.height);
                img.src = state.pages[i];
            }
        }
        function changePage(dir) {
            if(!state.isHost) return;
            savePage();
            const next = state.curPage + dir;
            if(next < 0) return;
            state.curPage = next;
            loadPage(next);
            document.getElementById('pgNum').innerText = "Page " + (next+1);
            send({t:'pg', i: next});
        }

        function downloadPDF() {
            savePage();
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'landscape' });
            const w = doc.internal.pageSize.getWidth();
            const h = doc.internal.pageSize.getHeight();
            
            state.pages.forEach((imgData, i) => {
                if(i > 0) doc.addPage();
                if(imgData) doc.addImage(imgData, 'PNG', 0, 0, w, h);
            });
            doc.save('sketchbook.pdf');
        }
    </script>
</body>
</html>