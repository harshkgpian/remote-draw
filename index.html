<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smooth Sync Canvas</title>
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        /* --- CSS STYLING --- */
        :root { --bg: #f0f2f5; --sidebar: #2c3e50; --accent: #007bff; --sidebar-width: 50px; }
        
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--bg); display: flex; height: 100vh; height: 100dvh; /* Dynamic Viewport Height */ }
        
        /* --- LOGIN PANEL --- */
        #loginOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(240, 242, 245, 0.98); z-index: 999;
            display: flex; justify-content: center; align-items: center;
        }
        .login-card {
            background: white; padding: 30px; border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); text-align: center; width: 85%; max-width: 350px;
        }
        .login-card h2 { margin-top: 0; color: #333; font-size: 22px; }
        .login-card input {
            width: 100%; padding: 12px; margin: 15px 0; border: 2px solid #e1e4e8; 
            border-radius: 8px; font-size: 16px; box-sizing: border-box; text-align: center;
        }
        .login-card input:focus { border-color: var(--accent); outline: none; }
        
        .btn {
            width: 100%; padding: 12px; margin: 6px 0; border: none; border-radius: 8px; 
            font-size: 15px; font-weight: 600; cursor: pointer; color: white; transition: 0.2s;
        }
        .btn-host { background: var(--accent); }
        .btn-viewer { background: #28a745; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }

        #status { margin-top: 15px; font-weight: bold; color: #666; font-size: 13px; }

        /* --- MAIN APP --- */
        #appContainer { display: none; width: 100%; height: 100%; }
        
        /* Sidebar - Slimmer & Safe Area Aware */
        #sidebar {
            width: var(--sidebar-width); background: var(--sidebar); 
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 15px; box-shadow: 4px 0 10px rgba(0,0,0,0.1); z-index: 10;
            justify-content: space-between; /* Push bottom icons down */
            padding-bottom: 20px; /* Base padding */
        }

        .tools-group {
            display: flex; flex-direction: column; align-items: center; width: 100%;
        }
        
        .tool-btn {
            width: 36px; height: 36px; border: none; background: transparent; color: #aab7c4;
            font-size: 16px; margin: 6px 0; cursor: pointer; border-radius: 8px; transition: 0.2s;
            display: flex; justify-content: center; align-items: center;
        }
        .tool-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        .tool-btn.active { background: var(--accent); color: white; }
        
        .divider { width: 50%; height: 1px; background: #44566c; margin: 8px 0; }
        
        .color-opt {
            width: 22px; height: 22px; border-radius: 50%; margin: 6px 0; cursor: pointer;
            border: 2px solid transparent; transition: 0.2s;
        }
        .color-opt.active { border-color: white; transform: scale(1.1); }

        /* Bottom group needs extra padding for mobile landscape address bars */
        .bottom-group {
            margin-bottom: env(safe-area-inset-bottom, 20px); /* Safe area + 20px */
            display: flex; flex-direction: column; align-items: center;
            padding-bottom: 40px; /* Extra lift for landscape */
        }

        /* Canvas Area */
        #mainArea { flex: 1; position: relative; background: #ddd; display: flex; justify-content: center; align-items: center; }
        
        #canvasWrapper {
            position: relative; background: white; box-shadow: 0 0 20px rgba(0,0,0,0.1);
            width: 100%; height: 100%; overflow: hidden;
        }
        canvas { display: block; cursor: crosshair; touch-action: none; }
    </style>
</head>
<body>

    <!-- LOGIN -->
    <div id="loginOverlay">
        <div class="login-card">
            <h2><i class="fas fa-bezier-curve"></i> Smooth Sync</h2>
            <input type="text" id="roomId" placeholder="Enter Room ID">
            <button class="btn btn-host" id="btnHost" onclick="startHost()">Start as HOST</button>
            <button class="btn btn-viewer" id="btnViewer" onclick="startViewer()">Join as VIEWER</button>
            <div id="status">Ready.</div>
        </div>
    </div>

    <!-- APP -->
    <div id="appContainer">
        <div id="sidebar">
            <!-- Top Tools -->
            <div class="tools-group">
                <button class="tool-btn active" id="t-pen" onclick="setTool('pen')"><i class="fas fa-pen"></i></button>
                <button class="tool-btn" id="t-eraser" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
                
                <div class="divider"></div>
                
                <div class="color-opt active" style="background: #000;" onclick="setColor('#000000', this)"></div>
                <div class="color-opt" style="background: #dc3545;" onclick="setColor('#dc3545', this)"></div>
                <div class="color-opt" style="background: #28a745;" onclick="setColor('#28a745', this)"></div>
                <div class="color-opt" style="background: #007bff;" onclick="setColor('#007bff', this)"></div>
            </div>

            <!-- Bottom Actions (Shifted Up) -->
            <div class="bottom-group">
                <button class="tool-btn" onclick="clearCanvas()"><i class="fas fa-trash"></i></button>
                <button class="tool-btn" onclick="toggleFullScreen()"><i class="fas fa-expand"></i></button>
            </div>
        </div>

        <div id="mainArea">
            <div id="canvasWrapper">
                <canvas id="drawCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbznWr6pH1DLfDXVAKneaQiWKkf-yQFBwm26o9ecU-Z8grk2X7L_lzWrzxP-c02aWMZ1/exec';
        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        
        const pc = new RTCPeerConnection(config);
        let dataChannel = null;
        let intervalId = null;

        // State
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentLineWidth = 3;
        
        // Drawing State
        const DAMPING_FACTOR = 0.85; // Controls smoothness (Higher = smoother but more lag)
        let isDrawing = false;
        let lastPoint = { x: 0, y: 0 };

        // DOM
        const statusEl = document.getElementById('status');
        const loginOverlay = document.getElementById('loginOverlay');
        const appContainer = document.getElementById('appContainer');
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const roomIdInput = document.getElementById('roomId');

        // --- INIT ---
        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const temp = canvas.toDataURL();
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const img = new Image();
            img.onload = () => ctx.drawImage(img, 0, 0);
            img.src = temp;
        }
        window.addEventListener('resize', resizeCanvas);

        // --- NETWORK ---
        async function sendToSheet(type, sdp) {
            statusEl.textContent = "Syncing...";
            try {
                await fetch(SCRIPT_URL, {
                    method: 'POST', mode: 'no-cors', 
                    headers: { 'Content-Type': 'text/plain' }, 
                    body: JSON.stringify({ id: roomIdInput.value.trim(), type: type, sdp: JSON.stringify(sdp) })
                });
            } catch(e) { statusEl.textContent = "Network Error"; }
        }

        async function readFromSheet() {
            const response = await fetch(`${SCRIPT_URL}?id=${roomIdInput.value.trim()}`);
            return await response.json();
        }

        pc.onconnectionstatechange = () => {
            if (pc.connectionState === "connected") {
                clearInterval(intervalId);
                statusEl.textContent = "Connected!";
                loginOverlay.style.display = 'none';
                appContainer.style.display = 'flex';
                resizeCanvas();
            }
        };

        // Host
        async function startHost() {
            if(!roomIdInput.value) return alert("Enter ID");
            document.getElementById('btnHost').disabled = true;
            dataChannel = pc.createDataChannel("draw");
            setupDrawingEvents();
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            pc.onicecandidate = async (e) => {
                if (!e.candidate) {
                    await sendToSheet('offer', pc.localDescription);
                    statusEl.textContent = "Waiting for Viewer...";
                    intervalId = setInterval(async () => {
                        const data = await readFromSheet();
                        if (data.answer) {
                            clearInterval(intervalId);
                            statusEl.textContent = "Connecting...";
                            await pc.setRemoteDescription(JSON.parse(data.answer));
                        }
                    }, 2000);
                }
            };
        }

        // Viewer
        async function startViewer() {
            if(!roomIdInput.value) return alert("Enter ID");
            document.getElementById('btnViewer').disabled = true;
            statusEl.textContent = "Searching...";
            intervalId = setInterval(async () => {
                const data = await readFromSheet();
                if (data.offer && pc.signalingState === "stable") {
                    clearInterval(intervalId);
                    statusEl.textContent = "Joining...";
                    await pc.setRemoteDescription(JSON.parse(data.offer));
                    pc.ondatachannel = (e) => { e.channel.onmessage = handleIncomingDraw; };
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    pc.onicecandidate = async (e) => {
                        if (!e.candidate) await sendToSheet('answer', pc.localDescription);
                    };
                }
            }, 2000);
        }

        // --- SMOOTH DRAWING LOGIC ---

        function getTransformedCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            // Scale isn't strictly necessary if canvas matches display size 1:1, 
            // but good for robustness:
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Interpolation for smoother lines (Damping)
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        function setupDrawingEvents() {
            const start = (e) => {
                e.preventDefault();
                isDrawing = true;
                lastPoint = getTransformedCoordinates(e);
                
                // Send Start config
                sendData({
                    t: 's', x: lastPoint.x, y: lastPoint.y,
                    c: (currentTool === 'eraser' ? '#ffffff' : currentColor),
                    w: (currentTool === 'eraser' ? 20 : currentLineWidth)
                });

                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.strokeStyle = (currentTool === 'eraser' ? '#ffffff' : currentColor);
                ctx.lineWidth = (currentTool === 'eraser' ? 20 : currentLineWidth);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            };

            const move = (e) => {
                e.preventDefault();
                if (!isDrawing) return;

                const rawPoint = getTransformedCoordinates(e);
                
                // --- SMOOTHING ALGORITHM ---
                // Instead of jumping directly to rawPoint, we move partway there.
                // This removes jagged edges from fast mouse movements.
                const smoothX = lerp(lastPoint.x, rawPoint.x, 1 - DAMPING_FACTOR);
                const smoothY = lerp(lastPoint.y, rawPoint.y, 1 - DAMPING_FACTOR);
                
                const newPoint = { x: smoothX, y: smoothY };

                // Quadratic Curve for rendering smoothness
                // Draw curve from lastPoint to midpoint of (last -> new)
                // Actually, simpler for P2P: Draw line to smoothed point.
                // Since points are generated frequently via smoothing, lines look like curves.
                ctx.lineTo(newPoint.x, newPoint.y);
                ctx.stroke();

                sendData({t: 'd', x: newPoint.x, y: newPoint.y});
                
                // Update last point to where we just drew
                lastPoint = newPoint; 
            };

            const end = () => { isDrawing = false; };

            canvas.addEventListener('mousedown', start);
            canvas.addEventListener('mousemove', move);
            canvas.addEventListener('mouseup', end);
            canvas.addEventListener('touchstart', start, {passive: false});
            canvas.addEventListener('touchmove', move, {passive: false});
            canvas.addEventListener('touchend', end);
        }

        function sendData(obj) {
            if (dataChannel && dataChannel.readyState === 'open') {
                // Normalize coords to 0-1 for sending to avoid screen size conflicts
                const payload = { ...obj };
                if(payload.x) payload.x = payload.x / canvas.width;
                if(payload.y) payload.y = payload.y / canvas.height;
                dataChannel.send(JSON.stringify(payload));
            }
        }

        // --- REMOTE HANDLER ---
        function handleIncomingDraw(e) {
            const d = JSON.parse(e.data);
            const w = canvas.width;
            const h = canvas.height;

            if(d.t === 's') {
                ctx.beginPath();
                ctx.moveTo(d.x * w, d.y * h);
                ctx.strokeStyle = d.c;
                ctx.lineWidth = d.w;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            } 
            else if(d.t === 'd') {
                ctx.lineTo(d.x * w, d.y * h);
                ctx.stroke();
            }
            else if(d.t === 'cls') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);
            }
        }

        // --- UI ---
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('t-'+tool).classList.add('active');
        }

        function setColor(color, el) {
            setTool('pen');
            currentColor = color;
            document.querySelectorAll('.color-opt').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
        }

        function clearCanvas() {
            if(confirm("Clear?")) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                sendData({t: 'cls'});
            }
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }

    </script>
</body>
</html>