<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vector Sync Fixed</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>

    <style>
        /* --- CSS STYLING --- */
        :root { --bg: #f0f2f5; --sidebar: #2c3e50; --accent: #007bff; --sidebar-width: 60px; }
        
        /* Lock the body completely */
        body { 
            margin: 0; overflow: hidden; 
            font-family: 'Segoe UI', sans-serif; 
            background: var(--bg); 
            display: flex; 
            height: 100vh; height: 100dvh; 
            width: 100vw;
            touch-action: none; 
        }
        
        /* --- LOGIN PANEL --- */
        #loginOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(240, 242, 245, 0.98); z-index: 999;
            display: flex; justify-content: center; align-items: center;
        }
        .login-card {
            background: white; padding: 30px; border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); text-align: center; width: 85%; max-width: 350px;
        }
        .login-card input {
            width: 100%; padding: 12px; margin: 15px 0; border: 2px solid #e1e4e8; 
            border-radius: 8px; font-size: 16px; box-sizing: border-box; text-align: center;
        }
        .btn {
            width: 100%; padding: 12px; margin: 6px 0; border: none; border-radius: 8px; 
            font-size: 15px; font-weight: 600; cursor: pointer; color: white; transition: 0.2s;
        }
        .btn-host { background: var(--accent); }
        .btn-viewer { background: #28a745; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        #status { margin-top: 15px; font-weight: bold; color: #666; font-size: 13px; }

        /* --- MAIN APP --- */
        #appContainer { display: none; width: 100%; height: 100%; }
        
        /* --- SIDEBAR (Fixed) --- */
        #sidebar {
            width: var(--sidebar-width); 
            min-width: var(--sidebar-width); /* Prevent shrinking */
            background: var(--sidebar); 
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 10px; padding-bottom: 10px;
            box-shadow: 4px 0 10px rgba(0,0,0,0.1); z-index: 10;
            
            /* SCROLLING LOGIC */
            height: 100%;
            overflow-y: auto; /* Scroll if content is too tall */
            overflow-x: hidden;
            
            /* Hide Scrollbar visually but keep functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE */
        }
        #sidebar::-webkit-scrollbar { display: none; /* Chrome/Safari */ }

        .sidebar-content {
            display: flex; flex-direction: column; align-items: center; width: 100%;
            /* Ensure content has breathing room at bottom so last item isn't cut off */
            padding-bottom: 20px; 
        }

        .tool-btn {
            width: 40px; height: 40px; border: none; background: transparent; color: #aab7c4;
            font-size: 18px; margin: 5px 0; cursor: pointer; border-radius: 8px; transition: 0.2s;
            display: flex; justify-content: center; align-items: center; flex-shrink: 0;
        }
        .tool-btn.active { background: var(--accent); color: white; }
        
        .color-opt {
            width: 24px; height: 24px; border-radius: 50%; margin: 6px 0; cursor: pointer;
            border: 2px solid transparent; transition: 0.2s; flex-shrink: 0;
        }
        .color-opt.active { border-color: white; transform: scale(1.1); }

        /* Slider for Stroke Size */
        .size-slider-container {
            display: flex; flex-direction: column; align-items: center; margin: 5px 0;
            color: #aab7c4; font-size: 10px;
        }
        input[type=range] {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical;
            width: 8px; height: 80px; padding: 0 5px;
            margin-top: 5px; cursor: ns-resize;
        }

        .divider { width: 50%; height: 1px; background: #44566c; margin: 8px 0; flex-shrink: 0; }

        /* --- MOBILE LANDSCAPE OPTIMIZATION --- */
        @media (max-height: 500px) {
            .tool-btn { width: 35px; height: 35px; margin: 2px 0; font-size: 16px; }
            .color-opt { margin: 4px 0; }
            input[type=range] { height: 50px; } /* Shrink slider */
            .slider-icon { display: none; } /* Hide helper icons in landscape */
            .divider { margin: 4px 0; }
            #sidebar { padding-top: 5px; }
        }

        /* Canvas Area */
        #mainArea { flex: 1; position: relative; background: #ddd; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #canvasWrapper {
            position: relative; background: white; box-shadow: 0 0 20px rgba(0,0,0,0.1);
            width: 100%; height: 100%; overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }

        /* Page Controls */
        #pageControls {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--sidebar); padding: 8px 15px; border-radius: 30px; color: white;
            display: flex; align-items: center; gap: 15px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            font-size: 14px; font-weight: bold; pointer-events: auto;
            transition: opacity 0.3s ease, transform 0.3s ease; 
            z-index: 20; white-space: nowrap;
        }
        #pageControls.fade-out { opacity: 0; transform: translateX(-50%) translateY(20px); pointer-events: none; }

        .pg-btn { background: none; border: none; color: white; cursor: pointer; font-size: 16px; display: flex; align-items: center; }
        .pg-btn:disabled { opacity: 0.5; cursor: default; }
        .sep { width: 1px; height: 15px; background: #555; margin: 0 5px; }

    </style>
</head>
<body>

    <!-- LOGIN -->
    <div id="loginOverlay">
        <div class="login-card">
            <h2><i class="fas fa-layer-group"></i> Vector Sync</h2>
            <input type="text" id="roomId" placeholder="Enter Room ID">
            <button class="btn btn-host" id="btnHost" onclick="startHost()">Start as HOST</button>
            <button class="btn btn-viewer" id="btnViewer" onclick="startViewer()">Join as VIEWER</button>
            <div id="status">Ready.</div>
        </div>
    </div>

    <!-- APP -->
    <div id="appContainer">
        <div id="sidebar">
            <div class="sidebar-content">
                <button class="tool-btn active" id="t-pen" onclick="setTool('pen')"><i class="fas fa-pen"></i></button>
                <button class="tool-btn" id="t-eraser" onclick="setTool('eraser')"><i class="fas fa-eraser"></i></button>
                
                <div class="divider"></div>
                
                <div class="size-slider-container">
                    <i class="fas fa-circle slider-icon" style="font-size: 16px; margin-bottom: 5px;"></i>
                    <input type="range" min="1" max="25" value="3" id="sizeSlider" oninput="updateSize(this.value)">
                    <i class="fas fa-circle slider-icon" style="font-size: 6px; margin-top: 5px;"></i>
                </div>

                <div class="divider"></div>
                
                <div class="color-opt active" style="background: #000;" onclick="setColor('#000000', this)"></div>
                <div class="color-opt" style="background: #dc3545;" onclick="setColor('#dc3545', this)"></div>
                <div class="color-opt" style="background: #28a745;" onclick="setColor('#28a745', this)"></div>
                <div class="color-opt" style="background: #007bff;" onclick="setColor('#007bff', this)"></div>
            </div>
        </div>

        <div id="mainArea">
            <div id="canvasWrapper">
                <canvas id="drawCanvas"></canvas>
            </div>
            
            <div id="pageControls">
                <button class="pg-btn" onclick="changePage(-1)"><i class="fas fa-chevron-left"></i></button>
                <span id="pageDisplay">Page 1</span>
                <button class="pg-btn" onclick="changePage(1)"><i class="fas fa-chevron-right"></i></button>
                
                <div class="sep"></div>
                
                <button class="pg-btn" onclick="downloadPDF()" title="Save PDF"><i class="fas fa-file-pdf"></i></button>
                <button class="pg-btn" onclick="deletePage()" title="Clear Page"><i class="fas fa-trash-alt"></i></button>
                <button class="pg-btn" onclick="toggleFullScreen()" title="Fullscreen"><i class="fas fa-expand"></i></button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbznWr6pH1DLfDXVAKneaQiWKkf-yQFBwm26o9ecU-Z8grk2X7L_lzWrzxP-c02aWMZ1/exec';
        const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
        const pc = new RTCPeerConnection(config);
        let dataChannel = null;
        let intervalId = null;

        // --- APP STATE ---
        let isHost = false;
        let currentTool = 'pen';
        let currentColor = '#000000';
        let currentSize = 3;

        // --- DATA ---
        let pages = [ [] ]; 
        let currentPageIndex = 0;

        // DOM
        const statusEl = document.getElementById('status');
        const loginOverlay = document.getElementById('loginOverlay');
        const appContainer = document.getElementById('appContainer');
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const roomIdInput = document.getElementById('roomId');
        const pageDisplay = document.getElementById('pageDisplay');
        const pageControls = document.getElementById('pageControls');

        // --- CANVAS SETUP ---
        function resizeCanvas() {
            const wrapper = document.getElementById('canvasWrapper');
            const rect = wrapper.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.resetTransform(); 
            ctx.scale(dpr, dpr);
            renderPage(currentPageIndex);
        }
        window.addEventListener('resize', resizeCanvas);

        // --- RENDER ENGINE ---
        function renderPage(pageIdx) {
            const rect = canvas.getBoundingClientRect();
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, rect.width, rect.height);

            const strokes = pages[pageIdx] || [];

            strokes.forEach(stroke => {
                if (stroke.isErased) return;
                ctx.beginPath();
                const startX = stroke.points[0].x * rect.width;
                const startY = stroke.points[0].y * rect.height;
                ctx.moveTo(startX, startY);
                if (stroke.points.length > 1) {
                    for (let i = 1; i < stroke.points.length; i++) {
                        const curr = stroke.points[i];
                        const prev = stroke.points[i-1];
                        const currX = curr.x * rect.width;
                        const currY = curr.y * rect.height;
                        const prevX = prev.x * rect.width;
                        const prevY = prev.y * rect.height;
                        if(i === 1) ctx.lineTo(currX, currY);
                        else {
                            const midX = (prevX + currX) / 2;
                            const midY = (prevY + currY) / 2;
                            ctx.quadraticCurveTo(prevX, prevY, midX, midY);
                        }
                    }
                    const last = stroke.points[stroke.points.length-1];
                    ctx.lineTo(last.x * rect.width, last.y * rect.height);
                } else {
                    ctx.lineTo(startX, startY);
                }
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
            });
        }

        // --- INTERACTION ---
        let isDrawing = false;
        let activeStroke = null;

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top,
                nx: (clientX - rect.left) / rect.width,
                ny: (clientY - rect.top) / rect.height
            };
        }

        function checkUICollision(y) {
            const rect = canvas.getBoundingClientRect();
            if (y > rect.height * 0.85) pageControls.classList.add('fade-out');
            else pageControls.classList.remove('fade-out');
        }

        function start(e) {
            e.preventDefault();
            const p = getPos(e);
            isDrawing = true;
            checkUICollision(p.y);

            if (currentTool === 'eraser') {
                checkForEraserHit(p);
                return;
            }

            activeStroke = {
                id: Date.now() + Math.random().toString(),
                points: [{x: p.nx, y: p.ny}],
                color: currentColor,
                size: currentSize,
                isErased: false
            };
            if(!pages[currentPageIndex]) pages[currentPageIndex] = [];
            pages[currentPageIndex].push(activeStroke);

            sendData({ t: 's', id: activeStroke.id, x: p.nx, y: p.ny, c: currentColor, w: currentSize });
            renderPage(currentPageIndex);
        }

        function move(e) {
            e.preventDefault();
            if (!isDrawing) return;
            const p = getPos(e);
            checkUICollision(p.y);

            if (currentTool === 'eraser') {
                checkForEraserHit(p);
                return;
            }
            if (!activeStroke) return;

            activeStroke.points.push({x: p.nx, y: p.ny});
            sendData({ t: 'd', id: activeStroke.id, x: p.nx, y: p.ny });
            renderPage(currentPageIndex);
        }

        function end() {
            isDrawing = false;
            activeStroke = null;
            pageControls.classList.remove('fade-out');
        }

        // --- ERASER ---
        function checkForEraserHit(pos) {
            const strokes = pages[currentPageIndex] || [];
            const rect = canvas.getBoundingClientRect();
            const threshold = 20;

            for (let i = strokes.length - 1; i >= 0; i--) {
                const s = strokes[i];
                if (s.isErased) continue;
                for (let pt of s.points) {
                    const px = pt.x * rect.width;
                    const py = pt.y * rect.height;
                    if (Math.abs(px - pos.x) < threshold && Math.abs(py - pos.y) < threshold) {
                        s.isErased = true;
                        sendData({ t: 'del', id: s.id });
                        renderPage(currentPageIndex);
                        return;
                    }
                }
            }
        }

        // --- NETWORK MSG ---
        function handleIncomingMsg(e) {
            const d = JSON.parse(e.data);
            if(!pages[currentPageIndex]) pages[currentPageIndex] = [];

            if (d.t === 's') {
                const newStroke = { id: d.id, points: [{x: d.x, y: d.y}], color: d.c, size: d.w, isErased: false };
                pages[currentPageIndex].push(newStroke);
            } 
            else if (d.t === 'd') {
                const s = pages[currentPageIndex].find(st => st.id === d.id);
                if (s) s.points.push({x: d.x, y: d.y});
            } 
            else if (d.t === 'del') {
                const s = pages[currentPageIndex].find(st => st.id === d.id);
                if (s) s.isErased = true;
            }
            else if (d.t === 'pg') {
                currentPageIndex = d.i;
                if (!pages[currentPageIndex]) pages[currentPageIndex] = [];
                updatePageUI();
            }
            else if (d.t === 'clr') pages[currentPageIndex] = [];

            renderPage(currentPageIndex);
        }

        // --- PDF EXPORT ---
        async function downloadPDF() {
            if(!window.jspdf) return alert("PDF Library not loaded.");
            const { jsPDF } = window.jspdf;
            const orientation = (canvas.width > canvas.height) ? 'landscape' : 'portrait';
            const pdf = new jsPDF({ orientation: orientation, unit: 'px', format: [canvas.width, canvas.height] });

            for(let i=0; i<pages.length; i++) {
                if(i > 0) pdf.addPage();
                renderPage(i);
                const imgData = canvas.toDataURL("image/png");
                pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
            }
            renderPage(currentPageIndex);
            pdf.save("MyNotes.pdf");
        }

        // --- WEBRTC ---
        async function sendToSheet(type, sdp) {
            statusEl.textContent = "Syncing...";
            try {
                await fetch(SCRIPT_URL, {
                    method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'text/plain' }, 
                    body: JSON.stringify({ id: roomIdInput.value.trim(), type: type, sdp: JSON.stringify(sdp) })
                });
            } catch(e) {}
        }
        async function readFromSheet() {
            const response = await fetch(`${SCRIPT_URL}?id=${roomIdInput.value.trim()}`);
            return await response.json();
        }
        pc.onconnectionstatechange = () => {
            if (pc.connectionState === "connected") {
                clearInterval(intervalId);
                statusEl.textContent = "Connected!";
                loginOverlay.style.display = 'none';
                appContainer.style.display = 'flex';
                resizeCanvas();
            }
        };
        async function startHost() {
            if(!roomIdInput.value) return alert("Enter ID");
            isHost = true;
            document.getElementById('btnHost').disabled = true;
            dataChannel = pc.createDataChannel("draw");
            setupEvents();
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            pc.onicecandidate = async (e) => {
                if (!e.candidate) {
                    await sendToSheet('offer', pc.localDescription);
                    statusEl.textContent = "Waiting for Viewer...";
                    intervalId = setInterval(async () => {
                        const data = await readFromSheet();
                        if (data.answer) {
                            clearInterval(intervalId);
                            statusEl.textContent = "Connecting...";
                            await pc.setRemoteDescription(JSON.parse(data.answer));
                        }
                    }, 2000);
                }
            };
        }
        async function startViewer() {
            if(!roomIdInput.value) return alert("Enter ID");
            isHost = false;
            document.getElementById('btnViewer').disabled = true;
            statusEl.textContent = "Searching...";
            intervalId = setInterval(async () => {
                const data = await readFromSheet();
                if (data.offer && pc.signalingState === "stable") {
                    clearInterval(intervalId);
                    statusEl.textContent = "Joining...";
                    await pc.setRemoteDescription(JSON.parse(data.offer));
                    pc.ondatachannel = (e) => { e.channel.onmessage = handleIncomingMsg; };
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    pc.onicecandidate = async (e) => {
                        if (!e.candidate) await sendToSheet('answer', pc.localDescription);
                    };
                }
            }, 2000);
        }
        function setupEvents() {
            canvas.addEventListener('mousedown', start);
            canvas.addEventListener('mousemove', move);
            canvas.addEventListener('mouseup', end);
            canvas.addEventListener('touchstart', start, {passive: false});
            canvas.addEventListener('touchmove', move, {passive: false});
            canvas.addEventListener('touchend', end);
        }
        function sendData(obj) { if (dataChannel && dataChannel.readyState === 'open') dataChannel.send(JSON.stringify(obj)); }
        function setTool(t) { currentTool = t; updateBtnState(); }
        function setColor(c, el) { 
            currentTool = 'pen'; currentColor = c; 
            document.querySelectorAll('.color-opt').forEach(e => e.classList.remove('active'));
            el.classList.add('active');
            updateBtnState();
        }
        function updateSize(val) { currentSize = parseInt(val); }
        function updateBtnState() {
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('t-'+currentTool).classList.add('active');
        }
        function changePage(dir) {
            if (!isHost) return alert("Only Host can change pages");
            const next = currentPageIndex + dir;
            if (next < 0) return;
            currentPageIndex = next;
            if (!pages[currentPageIndex]) pages[currentPageIndex] = [];
            updatePageUI();
            sendData({ t: 'pg', i: currentPageIndex });
            renderPage(currentPageIndex);
        }
        function deletePage() {
            if (!isHost) return;
            if (confirm("Clear this page?")) {
                pages[currentPageIndex] = [];
                sendData({ t: 'clr' });
                renderPage(currentPageIndex);
            }
        }
        function updatePageUI() { pageDisplay.innerText = "Page " + (currentPageIndex + 1); }
        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }
    </script>
</body>
</html>